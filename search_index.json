[["index.html", "Diagnostics Supplemental Material Chapter 1 Introduction 1.1 About our supplemental material 1.2 Contributing authors 1.3 Research overview 1.4 Experimental setup", " Diagnostics Supplemental Material Jose Guadalupe Hernandez 2022-11-22 Chapter 1 Introduction This is the supplemental material associated with our 2022 ECJ contribution entitled, A suite of diagnostic metrics for characterizing selection schemes. Preprint here. 1.1 About our supplemental material This supplemental material is hosted on GitHub using GitHub pages. The source code and configuration files used to generate this supplemental material can be found in this GitHub repository. We compiled our data analyses and supplemental documentation into this nifty web-accessible book using bookdown. Our supplemental material includes the following paper figures and statistics: Exploitation rate results (Section ??) Ordered exploitation results (Section ??) Contradictory objectives results (Section ??) Multi-path exploration results (Section ??) Multi-valley crossing results (Section 2) Additionally, our supplemental material includes the results from parameter tuning selection schemes: Truncation selection (Section ??) Tournament selection sharing (Section ??) Genotypic fitness sharing (Section ??) Phenotypic fitness sharing (Section ??) Nondominated sorting (Section ??) Novelty search (Section ??) 1.2 Contributing authors Jose Guadalupe Hernandez Alexander Lalejini Charles Ofria 1.3 Research overview Abstract: Evolutionary algorithms typically consist of multiple interacting components, where each component influences an algorithms problem-solving abilities. Understanding how each component of an evolutionary algorithm influences problem-solving success can improve our ability to target particular problem domains. Benchmark suites provide insights into an evolutionary algorithms problem-solving capabilities, but benchmarking problems often have complex search space topologies, making it difficult to isolate and test an algorithms strengths and weaknesses. Our work focuses on diagnosing selection schemes, which identify individuals to contribute genetic material to the next generation, thus driving an evolutionary algorithms search strategy. We introduce four diagnostics for empirically testing the strengths and weaknesses of selection schemes: the exploitation rate diagnostic, ordered exploitation rate diagnostic, contradictory objectives diagnostic, and the multi-path exploration diagnostic. Each diagnostic is a handcrafted search space designed to isolate and measure the relative exploitation and exploration characteristics of selection schemes. Here, we use our diagnostics to evaluate six population selection methods: truncation selection, tournament selection, fitness sharing, lexicase selection, nondominated sorting, and novelty search. Expectedly, tournament and truncation selection excelled at gradient exploitation but poorly explored search spaces, while novelty search excelled at exploration but failed to exploit gradients. Fitness sharing performed poorly across all diagnostics, suggesting poor overall exploitation and exploration abilities. Nondominated sorting was best for maintaining diverse populations comprised of individuals inhabiting multiple optima, but struggled to effectively exploit gradients. Lexicase selection balanced search space exploration without sacrificing exploitation, generally performing well across diagnostics. Our work demonstrates the value of diagnostics for building a deeper understanding of selection schemes, which can then be used to improve or develop new selection methods. 1.4 Experimental setup Setting up required variables variables. library(ggplot2) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # variables used throughout TRAITS = 100 TSIZE = 26 ORDER = c(&#39;Truncation (tru)&#39;,&#39;Tournament (tor)&#39;,&#39;Lexicase (lex)&#39;, &#39;Genotypic Fitness Sharing (gfs)&#39;,&#39;Phenotypic Fitness Sharing (pfs)&#39;,&#39;Nondominated Sorting (nds)&#39;,&#39;Novelty Search (nov)&#39;,&#39;Random (ran)&#39;) ACRON = tolower(c(&#39;TRU&#39;,&#39;TOR&#39;,&#39;LEX&#39;,&#39;GFS&#39;,&#39;PFS&#39;,&#39;NDS&#39;,&#39;NOV&#39;,&#39;RAN&#39;)) SHAPE = c(5,3,1,2,6,0,4,20,1) PARAM = c(&#39;8&#39;, &#39;8&#39;, &#39;0.0&#39;, &#39;0.3&#39;, &#39;0.3&#39;, &#39;0.3&#39;, &#39;15&#39;, &#39;1&#39;) cb_palette &lt;- c(&#39;#332288&#39;,&#39;#88CCEE&#39;,&#39;#EE7733&#39;,&#39;#EE3377&#39;,&#39;#117733&#39;,&#39;#882255&#39;,&#39;#44AA99&#39;,&#39;#CCBB44&#39;, &#39;#000000&#39;) GENERATIONS = 50000 # selection scheme parameters TR_LIST = c(1, 2, 4, 8, 16, 32, 64, 128, 256) TS_LIST = c(2, 4, 8, 16, 32, 64, 128, 256) FS_LIST = c(0.0, 0.1, 0.3, 0.6, 1.2, 2.5, 5.0) ND_LIST = c(0.0, 0.1, 0.3, 0.6, 1.2, 2.5, 5.0) NS_LIST = c(1, 2, 4, 8, 15, 30) # theme that graphs will follow p_theme &lt;- theme( text = element_text(size = 28), plot.title = element_text( face = &quot;bold&quot;, size = 22, hjust=0.5), panel.border = element_blank(), panel.grid.minor = element_blank(), legend.title=element_text(size=18), legend.text=element_text(size=14), axis.title = element_text(size=18), axis.text = element_text(size=16), legend.position=&quot;bottom&quot;, panel.background = element_rect(fill = &quot;#f1f2f5&quot;, colour = &quot;white&quot;, size = 0.5, linetype = &quot;solid&quot;) ) ## Warning: The `size` argument of `element_rect()` is deprecated as of ggplot2 3.4.0. ## i Please use the `linewidth` argument instead. # cross comparison data frames cc_over_time &lt;- read.csv(&#39;/opt/ECJ-2022-suite-of-diagnostics-for-selection-schemes/DATA-FINAL/POLISHED/cross-comp-over-time.csv&#39;, header = TRUE, stringsAsFactors = FALSE) colnames(cc_over_time)[colnames(cc_over_time) == &quot;Selection.Scheme&quot;] = &#39;Selection\\nScheme&#39; cc_over_time$`Selection\\nScheme` &lt;- factor(cc_over_time$`Selection\\nScheme`, levels = ORDER) cc_over_time$uni_str_pos = cc_over_time$uni_str_pos + cc_over_time$arc_acti_gene - cc_over_time$overlap cc_best = read.csv(&#39;/opt/ECJ-2022-suite-of-diagnostics-for-selection-schemes/DATA-FINAL/POLISHED/cross-comp-best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) cc_best$acron &lt;- factor(cc_best$acron, levels = ACRON) colnames(cc_best)[colnames(cc_best) == &quot;Selection.Scheme&quot;] = &#39;Selection\\nScheme&#39; cc_ssf = read.csv(&#39;/opt/ECJ-2022-suite-of-diagnostics-for-selection-schemes/DATA-FINAL/POLISHED/selection-scheme-ssf.csv&#39;, header = TRUE, stringsAsFactors = FALSE) cc_ssf$acron &lt;- factor(cc_ssf$acron, levels = ACRON) colnames(cc_over_time)[colnames(cc_over_time) == &quot;Selection.Scheme&quot;] = &#39;Selection\\nScheme&#39; cc_ssf[is.na(cc_ssf)] &lt;- 59999 cc_end &lt;- filter(cc_over_time, gen == 50000) cc_end$acron &lt;- factor(cc_end$acron, levels = ACRON) # selection scheme data frames ss_over_time &lt;- read.csv(&#39;/opt/ECJ-2022-suite-of-diagnostics-for-selection-schemes/DATA-FINAL/POLISHED/selection-scheme-over-time.csv&#39;, header = TRUE, stringsAsFactors = FALSE) colnames(ss_over_time)[colnames(ss_over_time) == &quot;Selection.Scheme&quot;] = &#39;Selection\\nScheme&#39; ss_over_time$uni_str_pos = ss_over_time$uni_str_pos + ss_over_time$arc_acti_gene - ss_over_time$overlap ss_best &lt;- read.csv(&#39;/opt/ECJ-2022-suite-of-diagnostics-for-selection-schemes/DATA-FINAL/POLISHED/selection-scheme-best.csv&#39;, header = TRUE, stringsAsFactors = FALSE) colnames(ss_best)[colnames(ss_best) == &quot;Selection.Scheme&quot;] = &#39;Selection\\nScheme&#39; ss_ssf &lt;- read.csv(&#39;/opt/ECJ-2022-suite-of-diagnostics-for-selection-schemes/DATA-FINAL/POLISHED/selection-scheme-ssf.csv&#39;, header = TRUE, stringsAsFactors = FALSE) colnames(ss_ssf)[colnames(ss_ssf) == &quot;Selection.Scheme&quot;] = &#39;Selection\\nScheme&#39; ## genotypic fitness sharing data frames gfs_ot &lt;- filter(ss_over_time, acron == &#39;gfs&#39;) gfs_ot$Sigma &lt;- factor(gfs_ot$trt, levels = FS_LIST) gfs_best &lt;- filter(ss_best, acron == &#39;gfs&#39;) gfs_best$Sigma &lt;- factor(gfs_best$trt, levels = FS_LIST) gfs_end &lt;- filter(gfs_ot, gen == 50000) ## phenotypic fitness sharing data frames pfs_ot &lt;- filter(ss_over_time, acron == &#39;pfs&#39;) pfs_ot$Sigma &lt;- factor(pfs_ot$trt, levels = FS_LIST) pfs_best &lt;- filter(ss_best, acron == &#39;pfs&#39;) pfs_best$Sigma &lt;- factor(pfs_best$trt, levels = FS_LIST) pfs_end &lt;- filter(pfs_ot, gen == 50000) ## nodominated sorting data frames nds_ot &lt;- filter(ss_over_time, acron == &#39;nds&#39;) nds_ot$Sigma &lt;- factor(nds_ot$trt, levels = ND_LIST) nds_best &lt;- filter(ss_best, acron == &#39;nds&#39;) nds_best$Sigma &lt;- factor(nds_best$trt, levels = ND_LIST) nds_end &lt;- filter(nds_ot, gen == 50000) ## novelty search data frames nov_ot &lt;- filter(ss_over_time, acron == &#39;nov&#39; &amp; trt != 0) nov_ot$K &lt;- factor(nov_ot$trt, levels = NS_LIST) nov_best &lt;- filter(ss_best, acron == &#39;nov&#39; &amp; trt != 0) nov_best$K &lt;- factor(nov_best$trt, levels = NS_LIST) nov_end &lt;- filter(nov_ot, gen == 50000) ## tournament data frames tor_ot &lt;- filter(ss_over_time, acron == &#39;tor&#39; &amp; trt != 1) tor_ot$T &lt;- factor(tor_ot$trt, levels = TS_LIST) tor_best &lt;- filter(ss_best, acron == &#39;tor&#39; &amp; trt != 1) tor_best$T &lt;- factor(tor_best$trt, levels = TS_LIST) tor_end &lt;- filter(tor_ot, gen == 50000) tor_ssf &lt;- filter(ss_ssf, acron == &#39;tor&#39; &amp; trt != 1) tor_ssf$T &lt;- factor(tor_ssf$trt, levels = TS_LIST) tor_ssf[is.na(tor_ssf)] &lt;- 59999 ## truncation data frames tru_ot &lt;- filter(ss_over_time, acron == &#39;tru&#39;) tru_ot$T &lt;- factor(tru_ot$trt, levels = TR_LIST) tru_best &lt;- filter(ss_best, acron == &#39;tru&#39;) tru_best$T &lt;- factor(tru_best$trt, levels = TR_LIST) tru_end &lt;- filter(tru_ot, gen == 50000) tru_ssf &lt;- filter(ss_ssf, acron == &#39;tru&#39;) tru_ssf$T &lt;- factor(tru_ssf$trt, levels = TR_LIST) tru_ssf[is.na(tru_ssf)] &lt;- 59999 These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status Patched ## major 4 ## minor 2.2 ## year 2022 ## month 11 ## day 10 ## svn rev 83330 ## language R ## version.string R version 4.2.2 Patched (2022-11-10 r83330) ## nickname Innocent and Trusting "],["multi-valley-crossing-results.html", "Chapter 2 Multi-valley crossing results 2.1 Analysis dependencies 2.2 Setup 2.3 Performance", " Chapter 2 Multi-valley crossing results Here we present the results for the best performances and best gene value generated by each selection scheme replicate on the multi-valley crossing diagnostic. Best performance found refers to the largest average trait score found in a given population. Best gene value refers to maximum gene value found in the population; this gives us a range of values in [0.0, 100.0]. 2.1 Analysis dependencies library(ggplot2) library(cowplot) library(dplyr) library(PupillometryR) 2.2 Setup These analyses were conducted in the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status Patched ## major 4 ## minor 2.2 ## year 2022 ## month 11 ## day 10 ## svn rev 83330 ## language R ## version.string R version 4.2.2 Patched (2022-11-10 r83330) ## nickname Innocent and Trusting 2.3 Performance Performance analysis. 2.3.1 Over time Best performance in a population over time. multivalley_crossing = dplyr::filter(cc_over_time, diagnostic == &#39;multivalley_crossing&#39;) lines = multivalley_crossing %&gt;% group_by(`Selection\\nScheme`, gen) %&gt;% dplyr::summarise( min = min(pop_fit_max), mean = mean(pop_fit_max), max = max(pop_fit_max) ) ## `summarise()` has grouped output by &#39;Selection Scheme&#39;. You can override using ## the `.groups` argument. points = filter(lines, gen %% 2000 == 0 &amp; gen != 0) ot = ggplot(lines, aes(x=gen, y=mean / TRAITS, group = `Selection\\nScheme`, fill =`Selection\\nScheme`, color = `Selection\\nScheme`, shape = `Selection\\nScheme`)) + geom_ribbon(aes(ymin = min / TRAITS, ymax = max / TRAITS), alpha = 0.1) + geom_line(size = 0.5) + geom_point(data = points, size = 1.5, stroke = 2.0, alpha = 1.0) + scale_y_continuous( name=&quot;Average trait score&quot;, limits=c(-1, 51), breaks=seq(0,50, 10), labels=c(&quot;0&quot;, &quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;) ) + scale_x_continuous( name=&quot;Generations&quot;, limits=c(0, 50000), breaks=c(0, 10000, 20000, 30000, 40000, 50000), labels=c(&quot;0e+6&quot;, &quot;1e+6&quot;, &quot;2e+6&quot;, &quot;3e+6&quot;, &quot;4e+6&quot;, &quot;5e+6&quot;) ) + scale_shape_manual(values=SHAPE)+ scale_colour_manual(values = cb_palette) + scale_fill_manual(values = cb_palette) + ggtitle(&quot;Best performance over time&quot;) + p_theme+ guides( shape=guide_legend(ncol=2, title.position = &quot;bottom&quot;), color=guide_legend(ncol=2, title.position = &quot;bottom&quot;), fill=guide_legend(ncol=2, title.position = &quot;bottom&quot;) ) + theme( legend.position = &quot;bottom&quot;, legend.box=&quot;verticle&quot;, legend.justification=&quot;center&quot;, legend.title=element_blank() ) ot 2.3.2 Best performance throughout Best performance throughout 50,000 generations. best = dplyr::filter(cc_best, col == &#39;pop_fit_max&#39; &amp; diagnostic == &#39;multivalley_crossing&#39;) # plot = ggplot(best, aes(x = acron, y = val / TRAITS, color = acron, fill = acron, shape = acron)) + # geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = &#39;width&#39;, alpha = 0.2) + # geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) + # geom_boxplot(color = &#39;black&#39;, width = .2, outlier.shape = NA, alpha = 0.0) + # scale_y_continuous( # name=&quot;Average trait score&quot;, # limits=c(-1, 51), # breaks=seq(0,50, 10), # labels=c(&quot;0&quot;, &quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;) # ) + # scale_x_discrete( # name=&quot;Scheme&quot; # )+ # scale_shape_manual(values=SHAPE)+ # scale_colour_manual(values = cb_palette) + # scale_fill_manual(values = cb_palette) + # p_theme # plot_grid( # plot + # ggtitle(&quot;Best performance throughout&quot;) + # theme(legend.position=&quot;none&quot;), # legend, # nrow=2, # rel_heights = c(2,.55), # label_size = TSIZE # ) 2.3.2.1 Stats Summary statistics for the best performance throughout 50,000 generations. best$acron &lt;- factor(best$acron, levels = c(&#39;pfs&#39;,&#39;gfs&#39;,&#39;nov&#39;,&#39;tor&#39;,&#39;tru&#39;,&#39;nds&#39;,&#39;ran&#39;,&#39;lex&#39;)) group_by(best, acron) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(val)), min = min(val, na.rm = TRUE), median = median(val, na.rm = TRUE), mean = mean(val, na.rm = TRUE), max = max(val, na.rm = TRUE), IQR = IQR(val, na.rm = TRUE) ) ## # A tibble: 8 x 8 ## acron count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 pfs 50 0 4127. 4288. 4296. 4492. 126. ## 2 gfs 50 0 4130. 4311. 4310. 4575. 87.6 ## 3 nov 50 0 1659. 1883. 1880. 2121. 114. ## 4 tor 50 0 1784. 1806. 1806. 1827. 9 ## 5 tru 50 0 1784. 1807. 1809. 1835 14.0 ## 6 nds 50 0 1463. 1544. 1547. 1656. 54.5 ## 7 ran 50 0 1100. 1306. 1314. 1562. 152. ## 8 lex 50 0 1248. 1273. 1272. 1296. 11.5 KruskalWallis test provides evidence of difference among best performances throughout 50,000 generations. # kruskal.test(val ~ acron,data = best) Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction on best performance throughout 50,000 generations. # pairwise.wilcox.test(x = best$val, g = best$acron, p.adjust.method = &quot;bonferroni&quot;, # paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) 2.3.3 End of 50,000 generations Best performance in the population at the end of 50,000 generations. end = dplyr::filter(cc_end, diagnostic == &#39;multivalley_crossing&#39;) # plot = ggplot(end, aes(x = acron, y = pop_fit_max / TRAITS, color = acron, fill = acron, shape = acron)) + # geom_flat_violin(position = position_nudge(x = .2, y = 0), scale = &#39;width&#39;, alpha = 0.2) + # geom_point(position = position_jitter(width = .1), size = 1.5, alpha = 1.0) + # geom_boxplot(color = &#39;black&#39;, width = .2, outlier.shape = NA, alpha = 0.0) + # scale_y_continuous( # name=&quot;Average trait score&quot;, # limits=c(-1, 51), # breaks=seq(0,50, 10), # labels=c(&quot;0&quot;, &quot;10&quot;, &quot;20&quot;, &quot;30&quot;, &quot;40&quot;, &quot;50&quot;) # ) + # scale_x_discrete( # name=&quot;Scheme&quot; # )+ # scale_shape_manual(values=SHAPE)+ # scale_colour_manual(values = cb_palette) + # scale_fill_manual(values = cb_palette) + # p_theme # plot_grid( # plot + # ggtitle(&quot;Final performance&quot;) + # theme(legend.position=&quot;none&quot;), # legend, # nrow=2, # rel_heights = c(2,.55), # label_size = TSIZE # ) 2.3.3.1 Stats Summary statistics for best performance in the population at the end of 50,000 generations. end$acron &lt;- factor(end$acron, levels = c(&#39;pfs&#39;,&#39;gfs&#39;,&#39;nov&#39;,&#39;tor&#39;,&#39;tru&#39;,&#39;nds&#39;,&#39;ran&#39;,&#39;lex&#39;)) group_by(end, acron) %&gt;% dplyr::summarise( count = n(), na_cnt = sum(is.na(pop_fit_max)), min = min(pop_fit_max, na.rm = TRUE), median = median(pop_fit_max, na.rm = TRUE), mean = mean(pop_fit_max, na.rm = TRUE), max = max(pop_fit_max, na.rm = TRUE), IQR = IQR(pop_fit_max, na.rm = TRUE) ) ## # A tibble: 8 x 8 ## acron count na_cnt min median mean max IQR ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 pfs 50 0 4105. 4272. 4275. 4482. 140. ## 2 gfs 50 0 4104. 4291. 4290. 4549. 90.7 ## 3 nov 50 0 1634. 1825. 1829. 2021. 114. ## 4 tor 50 0 1784. 1806. 1806. 1827. 9 ## 5 tru 50 0 1784. 1807. 1809. 1835 14.0 ## 6 nds 50 0 1440. 1496. 1502. 1644. 42.9 ## 7 ran 50 0 1081. 1289. 1274. 1511. 154. ## 8 lex 50 0 1186. 1229. 1227. 1265. 19.0 KruskalWallis test provides evidence of difference among best performances in the population at the end of 50,000 generations. # kruskal.test(pop_fit_max ~ acron,data = end) Results for post-hoc Wilcoxon rank-sum test with a Bonferroni correction on best performances in the population at the end of 50,000 generations. # pairwise.wilcox.test(x = end$pop_fit_max, g = end$acron, p.adjust.method = &quot;bonferroni&quot;, # paired = FALSE, conf.int = FALSE, alternative = &#39;l&#39;) "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
